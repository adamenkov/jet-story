ZX Spectrum memory

*	0000-3FFF	ROM
*	11AA		Based on (x, y) in BC (y in B, x in C; y grows downwards), calculate address in screen memory (HL) and pixel position in the byte (C mod 8)
*	4000-57FF	screen pixels (3 parts x 8 rows x32 columns x 8 pixels)
*	5800-5AFF	attributes
*	5DC0-6DBF	Initial map (128 x 8 x (y, x, 0, type)) of all game objects


*	6DD3-6DE1	Strange adjustment of HL after each pixel line of running line shift 1 pixel to the left
*	6DE2-6DE8	Z=1 iff no key is pressed.
*	6DE9-6DEE	Wait until key is pressed.
*	6DEF-6E07	Clear the screen and border.
*	6F4B-6F63	Shift the running line one pixel to the left.
*	6F64-7139	Text of running line and the trailing '$'.
*	713A-71C0	Spaces (' ')
*	71C1-71E7	The code that outputs the running line.
*	71E8-		String line to print a character, to call DECC (E18B) - character 2 sets row (17h) and column (1F), ?, ?, character to print (71ED)
*	71ED		The (invisible) symbol at the bottom right-hand corner - for the running line.
*	7213		Initialize game
*	8F00-9EFF	32 (actually, 29) 32x32 labyrinth elements' pixels
*	9F00-A0FF	attributes for the above
*	A100-A2FF	8 x 2 tables used to convert sprite byte to a pair of actual screen bytes based on sprite x (mod 8) coordinate
*	A4FF, A6FF, A8FF, A9FF, AAFF, ACFF, AEFF - bytes correspoding to 1, 2, 3, 4, 5, 6 pixel columns of bar (fuel, ammo, shield)
*	B100-...	16 x 16 sprites (no attributes)

*	C400-D3FF	Session-dependent (current) map (16 x 8 x (y, x, 0, type)) of all game objects

*	D400-DFB7	Labyrinth (encoded;  in byte b7b6b5b4b3b2b1b0, (b4b3b2b1b0 - 1) or 0 is the number of labyrinth block, b7b6b5 is the number it is repeated)
*	DEAB		Go to DF74
*	DECC-DECE	Go to E18B (draw a string with special characters)
*	DEF0-DEF1	Destination address in screen memory to print a character
*	DEF2		Attribute (What follows symbol 1 in a given string to print (in DEF2)).
*	DEF3		Height in pixels?
*	DF49		Render a room
*	DF74		Return (in HL) target address of the next pixel line of HUD

*	E011		Get the address of sprite number A in DE, address of screen memory where to draw it in HL, pixel offset (a2a1a0) in A, 1010_a2_a1_a0_1 in B (see A100)
*	E027		Draw a sprite
*	E0DD-E0E8	Give address (in DE) of graphics for character in A.
*	E139-E147	Calculate screen memory address (HL) based on row (0 <= H <= 17h) and column (0 <= L <= 1F).
*	E152-E16E	Actually draw character (in A) on screen, given its destination in screen memory (in HL).  E15B is either NOP or XOR (HL) (opcode AE).
*	E18B-		Draw a character.  Symbol 2 sets cursor at (row, column).  Symbol 1 sets attribute (puts the next symbol in (DEF2))
*	E1B8-E1E9	get key (Z=1 iff pressed). D = 5-group query mask, E = pressed key mask, B = group element counter, C = 5-key group counter
*	E1EA-E211	key table.  (element at 8 * key_number_1_to_5 + group_number_1_to_8 gives the pressed key)
*	E212-E21E	Wait for pressed key and play music/sound.
*	E21F-E243	Actually play the sound "key assigned".
*	E244-E24E	Play the sound "key assigned".
*	E358-E3C6	Guess: Update functions for Objects.
*	E3B2-E3B4	Go to ECBO (draw a bar of remaining quantity A, HL - destination screen memory address).
*	E3B5-E3B7	Go to ECF5
*	E3CB		Type of player bombs (1 - missiles, 2 - bombs, 3 - stars, 4 - balls)
*	E3CC		Quantity of player bombs
*	E3CE		Amount of ammo (0-255)
*	E3CF		Fuel remaining
*	E497		current room (1 byte)
*	E7C8-E7F4	Update the coordinates (?) and draw a sprite
*	E970-		Key "4. Start game" was press, wait for a keypress and start the game.
*	EADC-EB51	Play 48k main music.
*	EC8B-ECAF	Print a number in A (2 digits in BCD format).
*	ECBO-ECF4	Draw a bar of remaining quantity A, HL - destination screen memory address
*	ECF5-ED11	Probably some delays - everything is so quick if disabled (wrong: Render all objects (on screen))
*	EE4B		Go to FC76
*	EE51		Go to FB91 (Draw stats and objects, save current room enemies (?), go the glitch at room (3, 8)?)
*	EE58-EECF	6 game objects of the current room (6 x 20 bytes)
*	EED0		Shield remaining
*	EED1-F008(?)table of 8 bytes (of something) for each type (0-38)

*	F023-F028	Some initialization before the session?
*	F029-F04C	Render objects, update squares of HUD, update object location?
*	F052-F0AC	Prepare current room (copy objects from the map (C400) and draw HUD)
*	F0B8-F0C4	Given object type (IX), multiply it by 8 and add EED1 to return a pointer to some 8-byte structure in HL (which we later save in E3C9)
*	F0C5-F0CE	Get update function address for the given object type and call it.
*	F0CF-F0FC	Render current objects and update objects?
*	F0FF-F14B(?)Virtual table of update (?) functions for each object type
*	F163-		The join point for object update functions.
>>>	F53D-		Update the Big Z (object 14=0E)
*	F873-F875	Score (in BCD format)
*	F876		Number of bases left (in BCD for, starting from 47)
*	F889		Current room number again (like in E497)
*	F9B9-F9BC	"Notes" to play when the room is empty.

***	F9FB-FA2C	Main game (session) loop

*	FA2D-		Out of shield!
*	FA86-		Play music when current room is empty
*	FECA-		All bases destroyed (mission accomplished)
*	FAD5-FB47	Draw squares in HUD (first four character lines), then draw stats.
*	FA86-FAD4	???
*	FB44		Print current scores
*	FB56-FB59	Characters for player bombs on HUD ('a'/61h - missiles, 'c'/63h - bombs, 'f'/6F - stars, 'l'/6C - balls)
*	FB5A-FB90	Text of stats: "FUEL     AMMO     SHIELD  >    <    ^^ (2 bases)" (FB89,FB8A - player bomb characters))
*	FB91-FC14	Draw stats and objects, save current room enemies (?), go the glitch at room (3, 8)?
*	FC76-
*	FDCA-		Update timers?  (Without it, cannons don't shoot)



Game object (IX)
Each game object occupies 20 bytes of memory.  There are up to 6 16x16 objects in each room.
*	IX	object type (0 - killed?)
*	IX+1	old y coordinate (vertical coordinate in pixels from the top of the screen)
*	IX+2	old x coordinate (vertical coordinate in pixels from the left of the screen)
*	IX+3	old sprite number (in the catalog of all 16x16 sprites) / animation frame
*	IX+4	new y coordinate
*	IX+5	new x coordinate
*	IX+6	new sprite number / animation frame

Render order:
1. Maze and player
2. HUD
3. Enemies and objects